<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Image Tagger (Batch Mode)</title>
    <!-- 1. Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 2. piexif.js: To write metadata -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/piexifjs/1.0.6/piexif.min.js"></script>
    <!-- 3. jszip.js: To create a zip file for download -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <style>
        /* Simple Inter font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Simple CSS loader for the API call */
        .loader {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #3b82f6; /* Blue */
            border-radius: 50%;
            width: 32px;
            height: 32px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Helper to hide elements */
        .hidden {
            display: none;
        }
        /* Hide default file inputs */
        input[type="file"] {
            display: none;
        }
        /* Custom file input buttons */
        .custom-file-button {
            display: inline-block;
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        .custom-file-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .custom-file-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        /* Style for progress bar */
        progress::-webkit-progress-bar {
            background-color: #e0e0e0;
            border-radius: 8px;
        }
        progress::-webkit-progress-value {
            background-color: #3b82f6;
            border-radius: 8px;
            transition: width 0.3s ease;
        }
        progress::-moz-progress-bar {
            background-color: #3b82f6;
            border-radius: 8px;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

    <!-- Main Application Card -->
    <div class="bg-white rounded-2xl shadow-xl p-8 max-w-2xl w-full">
        <div class="flex justify-between items-center mb-6">
            <h1 class="text-3xl font-bold text-gray-800">AI Image Tagger</h1>
            <button id="settingsButton" class="text-gray-500 hover:text-blue-500">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-settings"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
            </button>
        </div>
        
        <p class="text-gray-600 mb-6">Select one or more JPEG images, or select a folder of images. This tool will use AI to generate a description for each one, write it to the metadata, and package all the new files into a single `.zip` download.</p>
        
        <!-- Step 1: Upload -->
        <div class="mb-4">
            <label class="block text-sm font-medium text-gray-700 mb-2">
                Step 1: Select Images
            </label>
            <div class="flex gap-2">
                <label for="singleImageUploader" class="custom-file-button flex-1 bg-blue-50 text-blue-700 hover:bg-blue-100">
                    Choose Images
                </label>
                <input id="singleImageUploader" type="file" accept="image/jpeg" multiple>
                
                <label for="folderUploader" class="custom-file-button flex-1 bg-green-50 text-green-700 hover:bg-green-100">
                    Choose Folder
                </label>
                <input id="folderUploader" type="file" accept="image/jpeg" webkitdirectory directory multiple>
            </div>
            <p class="text-xs text-gray-500 mt-2">Left: Choose Images | Right: Choose Folder</p>
        </div>
        
        <!-- Step 2: Generate -->
        <div class="mb-4">
            <label class="block text-sm font-medium text-gray-700 mb-2">
                Step 2: Start Batch Processing
            </label>
            <button id="generateButton" disabled class="w-full bg-blue-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-600 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center">
                <span id="generateButtonText">Start Processing</span>
                <div id="loader" class="loader hidden ml-3"></div>
            </button>
        </div>

        <!-- Step 3: Progress & Download -->
        <div id="progressContainer" class="hidden">
            <div class="mb-4">
                <label for="progressText" class="block text-sm font-medium text-gray-700 mb-2" id="progressLabel">
                    Processing Files...
                </label>
                <progress id="progressBar" class="w-full h-3 rounded-lg" value="0" max="100"></progress>
                <p id="progressText" class="text-sm text-gray-600 text-center mt-2"></p>
            </div>
            
            <!-- Optional Review Metadata Section -->
            <div id="reviewSection" class="mb-4 hidden">
                <button id="toggleReviewButton" class="w-full bg-gray-100 text-gray-700 font-medium py-2 px-4 rounded-lg hover:bg-gray-200 transition duration-300 flex items-center justify-between">
                    <span>üìù Review & Edit Metadata (Optional)</span>
                    <svg id="reviewArrow" class="w-5 h-5 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </button>
                
                <div id="reviewPanel" class="hidden mt-3 p-4 bg-gray-50 rounded-lg border border-gray-200">
                    <div id="reviewContent" class="space-y-4">
                        <!-- Dynamic content will be inserted here for each file -->
                    </div>
                </div>
            </div>
            
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">
                    Step 3: Download
                </label>
                <button id="downloadZipButton" class="w-full bg-green-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-600 transition duration-300 hidden">
                    Download Tagged Images
                </button>
            </div>
        </div>
        
        <!-- Error Message -->
        <div id="errorMessage" class="hidden text-red-600 font-medium text-center mt-4 p-3 bg-red-50 rounded-lg"></div>

    </div>

    <!-- Settings Modal (Hidden by default) -->
    <div id="settingsModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 hidden">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Settings</h2>
            <p class="text-gray-600 mb-4">Please enter your Google Cloud Vision API key. This key is saved *only* in your browser's local storage and is never sent to any server except Google's.</p>
            <div class="mb-4">
                <label for="apiKeyInput" class="block text-sm font-medium text-gray-700 mb-2">
                    Google Cloud Vision API Key
                </label>
                <input type="password" id="apiKeyInput" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
            </div>
            <div class="flex justify-end space-x-3">
                <button id="closeModalButton" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300">Close</button>
                <button id="saveApiKeyButton" class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600">Save Key</button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const settingsButton = document.getElementById('settingsButton');
        const settingsModal = document.getElementById('settingsModal');
        const closeModalButton = document.getElementById('closeModalButton');
        const saveApiKeyButton = document.getElementById('saveApiKeyButton');
        const apiKeyInput = document.getElementById('apiKeyInput');
        
        const singleImageUploader = document.getElementById('singleImageUploader');
        const folderUploader = document.getElementById('folderUploader');
        const generateButton = document.getElementById('generateButton');
        const generateButtonText = document.getElementById('generateButtonText');
        const loader = document.getElementById('loader');
        
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const downloadZipButton = document.getElementById('downloadZipButton');
        
        const reviewSection = document.getElementById('reviewSection');
        const toggleReviewButton = document.getElementById('toggleReviewButton');
        const reviewPanel = document.getElementById('reviewPanel');
        const reviewContent = document.getElementById('reviewContent');
        const reviewArrow = document.getElementById('reviewArrow');
        
        const errorMessage = document.getElementById('errorMessage');

        // --- Global State ---
        let pendingFiles = [];
        let processedFiles = []; // Store processed file data
        let zip = new JSZip();
        const API_KEY_NAME = 'googleApiKey';

        // --- Utility Functions ---
        function showMessage(msg, isError = true) {
            errorMessage.textContent = msg;
            errorMessage.className = isError 
                ? 'text-red-600 font-medium text-center mt-4 p-3 bg-red-50 rounded-lg' 
                : 'text-green-600 font-medium text-center mt-4 p-3 bg-green-50 rounded-lg';
            errorMessage.classList.remove('hidden');
        }

        function hideMessage() {
            errorMessage.classList.add('hidden');
        }

        function setLoading(isLoading) {
            if (isLoading) {
                generateButtonText.textContent = 'Processing...';
                loader.classList.remove('hidden');
                generateButton.disabled = true;
                singleImageUploader.disabled = true;
                folderUploader.disabled = true;
            } else {
                generateButtonText.textContent = 'Start Processing';
                loader.classList.add('hidden');
                generateButton.disabled = false;
                singleImageUploader.disabled = false;
                folderUploader.disabled = false;
            }
        }

        // --- Settings Modal Logic ---
        settingsButton.addEventListener('click', () => {
            settingsModal.classList.remove('hidden');
        });

        closeModalButton.addEventListener('click', () => {
            settingsModal.classList.add('hidden');
        });

        saveApiKeyButton.addEventListener('click', () => {
            const key = apiKeyInput.value.trim();
            if (key) {
                localStorage.setItem(API_KEY_NAME, key);
                settingsModal.classList.add('hidden');
                showMessage('API Key saved successfully.', false);
                setTimeout(hideMessage, 3000);
            } else {
                showMessage('Please enter a valid API key.');
            }
        });

        function loadApiKey() {
            const key = localStorage.getItem(API_KEY_NAME);
            if (key) {
                apiKeyInput.value = key;
            } else {
                settingsModal.classList.remove('hidden'); // Show modal if no key
            }
        }

        // --- Image Handling Logic ---
        function handleImageSelection(files) {
            hideMessage();
            progressContainer.classList.add('hidden');
            downloadZipButton.classList.add('hidden');
            reviewSection.classList.add('hidden');
            reviewPanel.classList.add('hidden');
            reviewArrow.style.transform = 'rotate(0deg)';
            zip = new JSZip(); // Reset the zip object
            processedFiles = []; // Reset processed files

            if (!files || files.length === 0) {
                return;
            }
            
            // Filter for JPEGs only
            pendingFiles = Array.from(files).filter(file => file.type === 'image/jpeg');

            if (pendingFiles.length === 0) {
                showMessage('No JPEG files found in the selection.');
                generateButton.disabled = true;
                return;
            }

            progressContainer.classList.remove('hidden');
            progressText.textContent = `Selected ${pendingFiles.length} JPEG file(s). Ready to process.`;
            generateButton.disabled = false;
        }
        
        // Helper function to modify filename
        function getModifiedFilename(originalFilename) {
            const lastDot = originalFilename.lastIndexOf('.');
            if (lastDot === -1) {
                return originalFilename + '-ai-meta-data';
            }
            const name = originalFilename.substring(0, lastDot);
            const ext = originalFilename.substring(lastDot);
            return name + '-ai-meta-data' + ext;
        }

        // --- Review UI Toggle ---
        toggleReviewButton.addEventListener('click', () => {
            const isHidden = reviewPanel.classList.contains('hidden');
            if (isHidden) {
                reviewPanel.classList.remove('hidden');
                reviewArrow.style.transform = 'rotate(180deg)';
            } else {
                reviewPanel.classList.add('hidden');
                reviewArrow.style.transform = 'rotate(0deg)';
            }
        });

        /**
         * Populates the review UI with editable metadata for all processed files
         */
        function populateReviewUI() {
            reviewContent.innerHTML = '';
            
            processedFiles.forEach((file, index) => {
                const fileSection = document.createElement('div');
                fileSection.className = 'border border-gray-300 rounded-lg p-3 bg-white';
                fileSection.innerHTML = `
                    <h4 class="font-semibold text-gray-800 mb-2 text-sm">${file.filename}</h4>
                    
                    <div class="mb-3">
                        <label class="block text-xs font-medium text-gray-700 mb-1">Caption (editable):</label>
                        <textarea 
                            id="caption-${index}" 
                            class="w-full p-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500" 
                            rows="2"
                        >${file.caption}</textarea>
                    </div>
                    
                    <div class="mb-3">
                        <label class="block text-xs font-medium text-gray-700 mb-1">Keywords (editable, comma-separated):</label>
                        <textarea 
                            id="keywords-${index}" 
                            class="w-full p-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500" 
                            rows="2"
                        >${file.keywords.join(', ')}</textarea>
                    </div>
                    
                    <div class="mb-2">
                        <label class="block text-xs font-medium text-gray-600 mb-1">Objects Detected:</label>
                        <p class="text-xs text-gray-500 italic">${file.objects.length > 0 ? file.objects.join(', ') : 'None detected'}</p>
                    </div>
                    
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">Text Detected (OCR):</label>
                        <p class="text-xs text-gray-500 italic">${file.ocrText}</p>
                    </div>
                `;
                reviewContent.appendChild(fileSection);
            });
            
            reviewSection.classList.remove('hidden');
        }

        /**
         * Gets the current (possibly edited) metadata from the review UI
         */
        function getEditedMetadata(index) {
            const captionEl = document.getElementById(`caption-${index}`);
            const keywordsEl = document.getElementById(`keywords-${index}`);
            
            if (captionEl && keywordsEl) {
                return {
                    caption: captionEl.value,
                    keywords: keywordsEl.value
                };
            }
            
            // Fallback to original if UI not populated
            return {
                caption: processedFiles[index].caption,
                keywords: processedFiles[index].keywords.join(', ')
            };
        }

        singleImageUploader.addEventListener('change', (event) => {
            folderUploader.value = ''; // Clear folder uploader
            handleImageSelection(event.target.files);
        });

        folderUploader.addEventListener('change', (event) => {
            singleImageUploader.value = ''; // Clear single image uploader
            handleImageSelection(event.target.files);
        });

        // --- Main Processing Logic ---
        generateButton.addEventListener('click', async () => {
            hideMessage();
            const apiKey = localStorage.getItem(API_KEY_NAME);

            if (!apiKey) {
                showMessage('Please set your Google Vision API key in Settings.');
                settingsModal.classList.remove('hidden');
                return;
            }

            if (pendingFiles.length === 0) {
                showMessage('Please select a folder containing JPEG images first.');
                return;
            }

            setLoading(true);
            downloadZipButton.classList.add('hidden');
            progressBar.value = 0;
            progressBar.max = pendingFiles.length;

            for (let i = 0; i < pendingFiles.length; i++) {
                const file = pendingFiles[i];
                progressText.textContent = `Processing "${file.name}" (${i + 1} of ${pendingFiles.length})...`;
                progressBar.value = i + 1;

                try {
                    // 1. Read file as Base64
                    const base64String = await readFileAsBase64(file);
                    
                    // 2. Call Google Vision API
                    const visionResponse = await callVisionApi(base64String, apiKey);
                    
                    // 3. Process Vision API response to get structured metadata
                    const metadata = processVisionResponse(visionResponse);
                    
                    // 4. Get modified filename
                    const modifiedFilename = getModifiedFilename(file.name);

                    // Store processed file info with separate metadata fields
                    const newImageData = base64String.split(',')[1];
                    processedFiles.push({
                        filename: modifiedFilename,
                        data: newImageData,
                        base64: base64String,
                        caption: metadata.caption,
                        keywords: metadata.keywords,
                        objects: metadata.objects,
                        ocrText: metadata.ocrText
                    });

                } catch (error) {
                    console.error(`Failed to process ${file.name}:`, error);
                    // Show error but continue to the next file
                    showMessage(`Skipped ${file.name}: ${error.message}`);
                }
            }
            
            // All files processed
            setLoading(false);
            progressText.textContent = `Processing Complete! ${processedFiles.length} files tagged.`;
            
            // Populate review UI
            populateReviewUI();
            
            // Update button text based on number of files
            if (processedFiles.length === 1) {
                downloadZipButton.textContent = 'Download Tagged Image';
            } else {
                downloadZipButton.textContent = 'Download Tagged Images (.zip)';
            }
            downloadZipButton.classList.remove('hidden');
        });

        // --- Helper Functions ---

        /**
         * Reads a File object and returns a Base64 encoded string.
         * @param {File} file - The file to read.
         * @returns {Promise<string>} - A promise that resolves with the base64 string.
         */
        function readFileAsBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error('File reading error: ' + e.target.error));
                reader.readAsDataURL(file);
            });
        }

        /**
         * Calls the Google Vision API with a base64 image.
         * @param {string} base64WithPrefix - The full "data:image/jpeg;base64,..." string.
         * @param {string} apiKey - The user's Google API key.
         * @returns {Promise<Object>} - A promise that resolves with the full Vision API response data.
         */
        async function callVisionApi(base64WithPrefix, apiKey) {
            const base64Data = base64WithPrefix.split(',')[1];
            const API_URL = `https://vision.googleapis.com/v1/images:annotate?key=${apiKey}`;
            
            const requestBody = {
                requests: [{
                    image: { content: base64Data },
                    features: [
                        { type: 'LABEL_DETECTION', maxResults: 20 },
                        { type: 'OBJECT_LOCALIZATION', maxResults: 15 },
                        { type: 'TEXT_DETECTION', maxResults: 1 },
                        { type: 'WEB_DETECTION', maxResults: 1 }
                    ]
                }]
            };

            const response = await fetch(API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error.message || 'Failed to call Google Vision API.');
            }

            const data = await response.json();
            
            // Process the response to build a description string
            if (!data.responses || !data.responses[0]) {
                throw new Error('Received an empty response from the API.');
            }
            
            return data.responses[0];
        }

        /**
         * Processes Vision API response to extract and construct better metadata.
         * @param {Object} visionResponse - The Vision API response object.
         * @returns {Object} - Object containing { caption, keywords, objects, ocrText }
         */
        function processVisionResponse(visionResponse) {
            const CONFIDENCE_THRESHOLD = 0.7;
            
            // Extract objects (most specific)
            let objects = [];
            if (visionResponse.localizedObjectAnnotations) {
                objects = visionResponse.localizedObjectAnnotations
                    .filter(obj => obj.score >= CONFIDENCE_THRESHOLD)
                    .map(obj => ({
                        name: obj.name,
                        score: obj.score
                    }))
                    .sort((a, b) => b.score - a.score);
            }
            
            // Extract OCR text
            let ocrText = '';
            if (visionResponse.textAnnotations && visionResponse.textAnnotations.length > 0) {
                ocrText = visionResponse.textAnnotations[0].description || '';
            }
            
            // Extract web entities
            let webEntities = [];
            if (visionResponse.webDetection && visionResponse.webDetection.webEntities) {
                webEntities = visionResponse.webDetection.webEntities
                    .filter(entity => entity.score >= CONFIDENCE_THRESHOLD && entity.description)
                    .map(entity => entity.description)
                    .slice(0, 3);
            }
            
            // Extract labels
            let labels = [];
            if (visionResponse.labelAnnotations) {
                labels = visionResponse.labelAnnotations
                    .filter(label => label.score >= CONFIDENCE_THRESHOLD)
                    .map(label => label.description);
            }
            
            // Build caption (natural language sentence)
            let captionParts = [];
            
            // Start with web entity if it provides context
            if (webEntities.length > 0) {
                captionParts.push(webEntities[0]);
            }
            
            // Add specific objects
            if (objects.length > 0) {
                const objectNames = objects.slice(0, 3).map(o => o.name.toLowerCase());
                if (captionParts.length > 0) {
                    captionParts.push('with ' + objectNames.join(', '));
                } else {
                    captionParts.push('Image contains ' + objectNames.join(', '));
                }
            }
            
            // Add OCR if present and short
            if (ocrText && ocrText.length > 0 && ocrText.length < 50) {
                captionParts.push('Text visible: "' + ocrText.trim().replace(/\n/g, ' ') + '"');
            }
            
            const caption = captionParts.length > 0 
                ? captionParts.join(' ')
                : (labels.length > 0 ? 'Image showing ' + labels.slice(0, 3).join(', ') : 'Image content detected');
            
            // Build keywords list (deduplicated, ordered by specificity)
            let allKeywords = [
                ...objects.map(o => o.name),
                ...webEntities,
                ...labels
            ];
            
            // Deduplicate (case-insensitive)
            const seen = new Set();
            const uniqueKeywords = allKeywords.filter(kw => {
                const lower = kw.toLowerCase();
                if (seen.has(lower)) return false;
                seen.add(lower);
                return true;
            });
            
            return {
                caption: caption,
                keywords: uniqueKeywords,
                objects: objects.map(o => `${o.name} (${Math.round(o.score * 100)}%)`),
                ocrText: ocrText ? ocrText.trim() : 'No text detected'
            };
        }

        /**
         * Injects a description string into an image's metadata.
         * @param {string} originalBase64 - The base64 string of the original image.
         * @param {string} description - The text to inject.
         * @returns {string} - The new base64 string with metadata.
         */
        function injectMetadata(originalBase64, description) {
            if (typeof piexif === 'undefined') {
                throw new Error('piexif.js library not loaded.');
            }

            try {
                // Try to load existing EXIF data
                let exifObj = piexif.load(originalBase64);
                
                // Add or update ImageDescription in 0th IFD
                if (!exifObj["0th"]) {
                    exifObj["0th"] = {};
                }
                exifObj["0th"][piexif.ImageIFD.ImageDescription] = description;
                
                // Add or update UserComment in Exif IFD
                if (!exifObj["Exif"]) {
                    exifObj["Exif"] = {};
                }
                exifObj["Exif"][piexif.ExifIFD.UserComment] = description;
                
                // Dump and insert
                const exifBytes = piexif.dump(exifObj);
                return piexif.insert(exifBytes, originalBase64);
                
            } catch (error) {
                // If loading fails, create new EXIF data
                console.warn('Could not load existing EXIF, creating new:', error);
                const exifObj = {
                    "0th": {
                        [piexif.ImageIFD.ImageDescription]: description
                    },
                    "Exif": {
                        [piexif.ExifIFD.UserComment]: description
                    }
                };
                const exifBytes = piexif.dump(exifObj);
                return piexif.insert(exifBytes, originalBase64);
            }
        }

        // --- Download ZIP Logic ---
        downloadZipButton.addEventListener('click', async () => {
            // Single file: Direct download
            if (processedFiles.length === 1) {
                const file = processedFiles[0];
                
                // Get edited metadata
                const metadata = getEditedMetadata(0);
                const description = `${metadata.caption}\n\nKeywords: ${metadata.keywords}`;
                
                // Inject metadata into the image
                const newBase64 = injectMetadata(file.base64, description);
                const newImageData = newBase64.split(',')[1];
                
                // Convert base64 to blob
                const byteCharacters = atob(newImageData);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                const blob = new Blob([byteArray], { type: 'image/jpeg' });
                
                // Create download link
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = file.filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
                
                progressText.textContent = 'Image downloaded successfully!';
                
            } else {
                // Multiple files: ZIP download
                progressText.textContent = 'Generating .zip file... This may take a moment.';
                
                try {
                    // Create new zip with metadata-injected images
                    const finalZip = new JSZip();
                    
                    for (let i = 0; i < processedFiles.length; i++) {
                        const file = processedFiles[i];
                        
                        // Get edited metadata
                        const metadata = getEditedMetadata(i);
                        const description = `${metadata.caption}\n\nKeywords: ${metadata.keywords}`;
                        
                        // Inject metadata into the image
                        const newBase64 = injectMetadata(file.base64, description);
                        const newImageData = newBase64.split(',')[1];
                        
                        finalZip.file(file.filename, newImageData, { base64: true });
                    }
                    
                    const content = await finalZip.generateAsync({ type: "blob" });
                    
                    // Create a download link and click it
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(content);
                    a.download = 'tagged-images.zip';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(a.href);

                    progressText.textContent = '.zip file successfully created!';

                } catch (error) {
                    console.error('ZIP generation error:', error);
                    showMessage(`Error creating .zip file: ${error.message}`);
                }
            }
        });

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            loadApiKey();
        });

    </script>
</body>
</html>
